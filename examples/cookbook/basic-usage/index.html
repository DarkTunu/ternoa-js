<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
    <link href="res/prism.css" rel="stylesheet" />
</head>

<body>

    <script>
        function show(shown) {
            let list = ["Page0", "Page1", "Page2"]
            for (page of list) {
                document.getElementById(page).style.display = page == shown ? 'block' : 'none';
            }
            return false;
        }
    </script>
    <script src="res/prism.js"></script>

    <div id="Page0">
        <b>Tutorial name:</b> Basic SDK usage
        <br><b>Date:</b> 2022-07-06
        <br><b>Keywords:</b> Create-Collection Create-NFT Batch-All List-NFT Buy-NFT Dummy-Data
        <br><b>Author:</b> Tiimy

        <br><br>Hello! üëã My name is Tiimy üåû

        <br>My job is to show you how powerful and yet convenient our API is.
        <br>In this exercise, we will go through the most common workflow and make sure that you understand the basic
        principles in coding with our SDK.

        <blockquote>
            <b>‚ö†Ô∏è It's important to mention that we will be using dummy data in this exercise.
                For a an example with production data check out the metadata exercise. </b>
        </blockquote>

        Let's first lay down all the tasks that we need to do:
        <br> Tasks:
        <br>&nbsp;&nbsp;&nbsp;&nbsp; I. Create a collection with the name Bored Dog Yacht Club (limited to 10)
        <br>&nbsp;&nbsp;&nbsp;&nbsp; II. Create 10 NFTs that hold the most used dog names
        <br>&nbsp;&nbsp;&nbsp;&nbsp; III. Put all NFTs on for sale
        <br>&nbsp;&nbsp;&nbsp;&nbsp; IV. Buy one of listed NFTs

        <br><br>Seems easy, right? So let's start!
        <br><br><button onclick="return show('Page1');">Click me to continue!</button>
    </div>

    <div id="Page1" style="display:none">
        <br> Tasks:
        <br>&nbsp;&nbsp;&nbsp;&nbsp; <b>I. Create a collection with the name Bored Dog Yacht Club (limited to 10) </b>
        <br>&nbsp;&nbsp;&nbsp;&nbsp; II. Create 10 NFTs that hold the most used dog names
        <br>&nbsp;&nbsp;&nbsp;&nbsp; III. Put all NFTs on for sale
        <br>&nbsp;&nbsp;&nbsp;&nbsp; IV. Buy one of listed NFTs




        <br><br> In order to create a collection we need the following steps:
        <br> - I. Create an account
        <br> - II. Define the metadata for collection
        <br> - III. Execution Trigger

        <h3>I. Account</h3>
        To create an collection we need an entity which is going to sign and submit the transactions that will create
        that collection. You either can create a new account and use the faucet to get some funds or you can use the
        standard Ternoa Example account for that.

        <pre><code class="language-js">
            // If needed, you can replace //TernoaTestAccount with your own account seed
            let keyring = await getKeyringFromSeed("//TernoaTestAccount");
        </code></pre>

        <h3>II. Metadata</h3>
        The collection metadata consists of two entities: collection off-chain-data and collection limit.

        <br><b>Collection off-chain-data</b> can be anything, it can be the name of the collection, it can be a link to
        a file that contains a detailed description of our collection or it can a IPFS reference. In this example we
        will use the name of our collection as the off-chain-data.

        <br><br><b>Collection limit</b> allows us to either define an open ended collection if not specific or a limited
        collection.
        In order to make our club a exclusive society, we will limit the collection size to 10.

        <pre><code class="language-js">
            // In practice, this would be a link or a IPFS reference
            let collectionOffchainData = "Bored Dog Yacht Club (BDYC)";

            // This can be set to undefined if we want to have a open ended collection.
            let limit = 10;
        </code></pre>

        <h3>III. Execution Trigger</h3>
        There is a separate page which discusses this topic in more details but the gist is that we provide two
        different execution triggers. On one trigger we wait for the transaction to be included in the not-finalized
        block and on the other trigger we wait for the transaction to be included inside a finalized block.

        <br> In this example and when you do your testing you can saftly always just the BlockInclusion trigger but in
        production you would use the BlockFinalization trigger.
        <pre><code class="language-js">
            // In production code you would wait for the transaction to be inside a finalized block.
            let executionTrigger = WaitUntil.BlockInclusion;
        </code></pre>

        <h3>Time to shine</h3>
        With all the preparation done, we can finally create a collection. We just need to call the right function and
        pass all our already defined data.

        <pre><code class="language-js">
            // This call can take up to 6 seconds to finish. The return value is the Collection Event or in case of an 
            // error a exception will be thrown.
            let collectionEvent = await createCollection(collectionOffchainData, limit, keyring, executionTrigger);

            // Printout collection
            console.log(collectionEvent);
        </code></pre>

        <br><button onclick="return show('Page0');">Go back</button>
        <button onclick="return show('Page2');">Next Page</button>
    </div>

    <div id="Page2" style="display:none">
        <br>- 1. Create a collection
        <br><b>- 2. Add 10 prestigious dogs to our collection</b>
        <br>- 3. Put one dog for sale

        <br><br> In order to create a collection we need the following steps:
        <br> - I. Create an account
        <br> - II. Define the metadata for collection
        <br> - III. Execution Trigger

        <h3>I. Account</h3>
        To create an collection we need an entity which is going to sign and submit the transactions that will create
        that collection. You either can create a new account and use the faucet to get some funds or you can use the
        standard Ternoa Example account for that.

        <pre><code class="language-js">
            // If needed, you can replace //TernoaTestAccount with your own account seed
            let keyring = await getKeyringFromSeed("//TernoaTestAccount");
        </code></pre>

        <h3>II. Metadata</h3>
        The collection metadata consists of two entities: collection off-chain-data and collection limit.

        <br><b>Collection off-chain-data</b> can be anything, it can be the name of the collection, it can be a link to
        a file that contains a detailed description of our collection or it can a IPFS reference. In this example we
        will use the name of our collection as the off-chain-data.

        <br><br><b>Collection limit</b> allows us to either define an open ended collection if not specific or a limited
        collection.
        In order to make our club a exclusive society, we will limit the collection size to 10.

        <pre><code class="language-js">
            // In practice, this would be a link or a IPFS reference
            let collectionOffchainData = "Bored Dog Yacht Club (BDYC)";

            // This can be set to undefined if we want to have a open ended collection.
            let limit = 10;
        </code></pre>

        <h3>III. Execution Trigger</h3>
        There is a separate page which discusses this topic in more details but the gist is that we provide two
        different execution triggers. On one trigger we wait for the transaction to be included in the not-finalized
        block and on the other trigger we wait for the transaction to be included inside a finalized block.

        <br> In this example and when you do your testing you can saftly always just the BlockInclusion trigger but in
        production you would use the BlockFinalization trigger.
        <pre><code class="language-js">
            // In production code you would wait for the transaction to be inside a finalized block.
            let executionTrigger = WaitUntil.BlockInclusion;
        </code></pre>

        <h3>Time to shine</h3>
        With all the preparation done, we can finally create a collection. We just need to call the right function and
        pass all our already defined data.

        <pre><code class="language-js">
            // This call can take up to 6 seconds to finish. The return value is the Collection Event or in case of an 
            // error a exception will be thrown.
            let collectionEvent = await createCollection(collectionOffchainData, limit, keyring, executionTrigger);

            // Printout collection
            console.log(collectionEvent);
        </code></pre>

        <br><button onclick="return show('Page1');">Go back</button>
        <button onclick="return show('Page3');">Next Page</button>
    </div>
</body>

</html>